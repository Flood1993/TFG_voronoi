#LyX 2.1 created this file. For more info see http://www.lyx.org/
\lyxformat 474
\begin_document
\begin_header
\textclass amsart
\use_default_options true
\begin_modules
theorems-ams
eqs-within-sections
figs-within-sections
\end_modules
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman default
\font_sans default
\font_typewriter default
\font_math auto
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry false
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 1
\tocdepth 1
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Part*
INDEX
\end_layout

\begin_layout Section
Summary
\end_layout

\begin_layout Section
Introduction and objectives
\end_layout

\begin_layout Standard
What is a partition.
 Voronoi diagrams.
\end_layout

\begin_layout Standard
Introduction to symmetric dyfference.
 How we will calculate it (substracting area from the square).
 Different methods to calculate it.
\end_layout

\begin_layout Standard
Objectives: Minimize the total difference between a given partition and
 the one we search in a reasonable execution time.
\end_layout

\begin_layout Standard
We would like to be able to find the generating points of perfect Voronoi
 diagrams (it is not guaranteed we will be able to).
\end_layout

\begin_layout Section
Development
\end_layout

\begin_layout Standard
Why Processing.
 Pros and cons of Java.
\end_layout

\begin_layout Standard
--------First (naive) idea about the development.--------
\end_layout

\begin_layout Standard
Line and polygon clipping.
 Divide and conquer.
 Robustness.
\end_layout

\begin_layout Standard
Input data.
\end_layout

\begin_layout Standard
Output data.
\end_layout

\begin_layout Standard
Gradient method.
\end_layout

\begin_layout Standard
Simmulated annealing.
\end_layout

\begin_layout Standard
Getting rid of the 
\begin_inset Quotes eld
\end_inset

repetition
\begin_inset Quotes erd
\end_inset

 problem: randomizing point order in each state.
\end_layout

\begin_layout Section
Results and conclusions
\end_layout

\begin_layout Standard
Comparing different configurations, their results as well as their execution
 times.
\end_layout

\begin_layout Standard
Different ways of comparing the results.
\end_layout

\begin_layout Standard
Total minimum area.
\end_layout

\begin_layout Standard
Most average area reduced per step.
\end_layout

\begin_layout Standard
Conclusions.
\end_layout

\begin_layout Section
Appendices
\end_layout

\begin_layout Section
Bibliography
\end_layout

\begin_layout Part*
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Part*
SUMMARY
\end_layout

\begin_layout Standard
Voronoi diagrams have practical and theoretical applications to a large
 number of fields, mainly in science, technology and visual art.
 The aim of my project is to study the inverse Voronoi diagram problem and
 design, compare and analyze different strategies for its solving.
 The inverse Voronoi diagram problem consists on detecting whether a given
 plane partition is a Voronoi diagram and finding the seed points that would
 generate such a partition.
 For a partition which does not come from a Voronoi diagram, it would be
 interesting to find the best fitting Voronoi diagram.
 At this point, we need a way to measure how good a candidate solution is.
 We will be using the total symmetric difference between the two partitions.
 
\end_layout

\begin_layout Standard
Note that despite the search space is bounded, it being continuous grants
 an infinite number of solution candidates.
 Therefore, we will try to solve the problem using different metaheuristic,
 which makes it impossible to tell whether the obtained solution is optimum.
\end_layout

\begin_layout Standard
The basic steps of all the strategies are:
\end_layout

\begin_layout Itemize
For each input, calculate a set of seed points from which we will start.
\end_layout

\begin_layout Itemize
Move each point slightly following some criteria and check if we improved
 the current best solution.
\end_layout

\begin_layout Itemize
Repeat last step until we cannot keep improving or we are satisfied with
 the result.
\end_layout

\begin_layout Part*
RESUMEN
\end_layout

\begin_layout Standard
Los diagramas de Voronoi tienen aplicaciones tanto prácticas como teóricas
 en muchos ámbitos, la mayoría relacionados con la ciencia y tecnología,
 aunque también se aplica en otros como el arte visual.
 El objetivo de mi proyecto es estudiar el problema inverso del diagrama
 de Voronoi y diseñar, comparar y analizar diferentes estrategias para su
 resolución.
 Dicho problema consiste en detectar si una partición dada es o no un diagrama
 de Voronoi, y calcular las semillas que lo generan en caso afirmativo.
 Para particiones que no lo son, sería interesante encontrar el diagrama
 de Voronoi que mejor se aproxima.
 Para ello, necesitaremos alguna forma de evaluar como de buena es una solución.
 Usaremos la diferencia simétrica entre las dos particiones para tal fin.
\end_layout

\begin_layout Standard
Nótese que pese a que el espacio de búsqueda es acotado, al ser continuo
 hay infinitos candidatos que habría que probar, lo cual es inviable.
 Por tanto, trataremos de resolver el problema mediante diferentes metaheurístic
as, aunque en ningún caso podremos asegurar que la solución obtenida es
 óptima.
\end_layout

\begin_layout Standard
El esquema básico de todas las estrategias es el siguiente:
\end_layout

\begin_layout Itemize
Para cada datos de entrada, calcular un conjunto de puntos semilla a partir
 de los cuales comenzaremos la búsqueda.
\end_layout

\begin_layout Itemize
Desplazamos los puntos ligeramente según algún criterio y comprobamos si
 hemos conseguido mejorar nuestra solución, actualizando ésta en ese caso.
\end_layout

\begin_layout Itemize
Repetimos el paso anterior hasta que no podamos seguir mejorando o hasta
 que la solución obtenida se considere lo suficientemente buena.
\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Part*
INTRODUCTION
\end_layout

\begin_layout Standard
There are some concepts the reader should be familiar with in order to follow
 this document without problems.
 Those are:
\end_layout

\begin_layout Itemize
Partition of a set.
 Partition of the square unit.
\end_layout

\begin_layout Itemize
Voronoi diagrams.
\end_layout

\begin_layout Itemize
Symmetric difference.
\end_layout

\begin_layout Subsection*
Partition of a set.
 Partition of the square unit.
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
A partition of a set is a grouping of the set's elements into non-empty
 subsets, in such a way that every element is included in one and only one
 of the subsets.
\end_layout

\begin_layout Standard
In our case, we will be working with partitions of the square unit.
 That is, a set of polygons such that the union is the square unit and the
 intersection of two polygons is, at most, a segment.
 Note that there might be points contained in more than one polygon.
\end_layout

\begin_layout Subsection
Voronoi diagrams.
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
A Voronoi diagram is a partitioning of a plane into regions (called Voronoi
 cells) based on distance to points (called seeds or generators) in a specific
 subset of the plane.
 In this project we will only be using the simplest case of Voronoi diagrams:
 the seeds are given as a finite set of points in the Euclidian plane.
\end_layout

\begin_layout Standard
The lines that appear in a Voronoi diagram are the points of the plane that
 are equidistant to two or more of the nearest seeds.
\end_layout

\begin_layout Subsection*
Symmetric difference.
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
For measuring how good a given solution is, we will rely on the symmetric
 difference as an indicator.
 For two given polygons A and B, the symmetric difference can be calculated
 as follows:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
SD(A,B)=Area(A\bigcup B)-Area(A\bigcap B)
\]

\end_inset


\end_layout

\begin_layout Standard
Applying this concept to two partitions, we can define the symmetric difference
 of two partitions as the sum of all the symmetric differences for each
 pair of related polygons.
\end_layout

\begin_layout Standard
Another way of calculating it would be to substract from the area of the
 unit square, the area of the intersections of every pair of related polygons.
\end_layout

\begin_layout Standard
We will be treating this value as a ratio with the total area of the unit
 square, so a 0% value will mean the two partitions are exactly the same.
\end_layout

\begin_layout Part*
OBJECTIVES
\end_layout

\begin_layout Standard
The objectives of this project are:
\end_layout

\begin_layout Itemize
Fit a given partition of the square unit as much as we can through Voronoi
 diagrams.
 Therefore, the variable we want to minimize is the resulting symmetric
 difference between the input and the solution given.
\end_layout

\begin_layout Itemize
If the given partition is in fact a Voronoi diagram, we would like to arrive
 to that conclusion.
 Even though this looks trivial, it will be very difficult to get there
 for non trivial input, since the number of local minimums that have to
 be avoided to find the seeds increases in a different magnitude compared
 to the number of polygons.
\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Part*
DEVELOPMENT
\end_layout

\begin_layout Subsection
Why Processing.
 Pros and cons of Java.
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
ga
\end_layout

\begin_layout Subsection*
Line and polygon clipping.
 Divide and conquer.
 Robustness.
\end_layout

\begin_layout Standard
a
\end_layout

\begin_layout Subsection*
Input data.
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
The input data for the problem is a partition of the square unit.
 That is, a set of polygons whose union is the square unit and, for every
 two polygons, its intersection is at most a straight line.
 More precisely, each polygon is given as a set of ordered 2D points.
 At first, we know we will be working only with convex polygons (that is,
 all internal angles are less or equal than 180 degrees).
\end_layout

\begin_layout Subsection*
Output data.
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
The program generates various files after being executed.
 The files will be located in the 
\begin_inset Quotes eld
\end_inset

voronoi
\begin_inset Quotes erd
\end_inset

 folder, and will be the following:
\end_layout

\begin_layout Itemize
output.csv: CSV file in which each line represents each iteration of the
 algorithm.
 Each line contains information of where each seed point was at that stage
 and the symmetric difference in that precise step.
\end_layout

\begin_layout Itemize
before.png: Image that displays the first approximation of the Voronoi diagram.
\end_layout

\begin_layout Itemize
after.png: Image that displays the final approximation of the Voronoi diagram.
\end_layout

\begin_layout Subsection*
Gradient method.
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
a
\end_layout

\begin_layout Subsection*
Simmulated annealing.
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
a
\end_layout

\begin_layout Subsubsection*
Getting rid of the 
\begin_inset Quotes eld
\end_inset

repetition
\begin_inset Quotes erd
\end_inset

 problem: randomizing point order in each state.
\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Part*
Bibliografía
\end_layout

\begin_layout Standard
https://processing.org – Open source programming language and IDE in which
 the whole project is coded 
\end_layout

\begin_layout Standard
http://leebyron.com/mesh/ - External processing library used for calculating
 the Voronoi diagrams
\end_layout

\begin_layout Standard
http://www.lyx.org/ - Document processor used for writing this thesis
\end_layout

\begin_layout Standard
https://github.com/Flood1993/TFG_voronoi - Git repository containing everything
 about this project
\end_layout

\end_body
\end_document
