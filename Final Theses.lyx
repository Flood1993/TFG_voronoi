#LyX 2.1 created this file. For more info see http://www.lyx.org/
\lyxformat 474
\begin_document
\begin_header
\textclass amsart
\use_default_options true
\begin_modules
theorems-ams
eqs-within-sections
figs-within-sections
\end_modules
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman default
\font_sans default
\font_typewriter default
\font_math auto
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry false
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 1
\tocdepth 1
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Part*
INDEX
\end_layout

\begin_layout Section
Summary
\end_layout

\begin_layout Section
Introduction and objectives
\end_layout

\begin_layout Standard
What is a partition.
 Voronoi diagrams.
\end_layout

\begin_layout Standard
Introduction to symmetric dyfference.
 How we will calculate it (substracting area from the square).
 Different methods to calculate it.
\end_layout

\begin_layout Standard
Objectives: Minimize the total difference between a given partition and
 the one we search in a reasonable execution time.
\end_layout

\begin_layout Standard
We would like to be able to find the generating points of perfect Voronoi
 diagrams (it is not guaranteed we will be able to).
\end_layout

\begin_layout Section
Development
\end_layout

\begin_layout Standard
Why Processing.
 Pros and cons of Java.
\end_layout

\begin_layout Standard
--------First (naive) idea about the development.--------
\end_layout

\begin_layout Standard
Line and polygon clipping.
 Divide and conquer.
 Robustness.
\end_layout

\begin_layout Standard
Input data.
\end_layout

\begin_layout Standard
Output data.
\end_layout

\begin_layout Standard
Gradient method.
\end_layout

\begin_layout Standard
Simulated annealing.
\end_layout

\begin_layout Standard
Getting rid of the 
\begin_inset Quotes eld
\end_inset

repetition
\begin_inset Quotes erd
\end_inset

 problem: randomizing point order in each state.
\end_layout

\begin_layout Section
Results and conclusions
\end_layout

\begin_layout Standard
Comparing different configurations, their results as well as their execution
 times.
\end_layout

\begin_layout Standard
Different ways of comparing the results.
\end_layout

\begin_layout Standard
Total minimum area.
\end_layout

\begin_layout Standard
Most average area reduced per step.
\end_layout

\begin_layout Standard
Conclusions.
\end_layout

\begin_layout Section
Appendices
\end_layout

\begin_layout Section
Bibliography
\end_layout

\begin_layout Part*
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Part*
SUMMARY
\end_layout

\begin_layout Standard
Voronoi diagrams have practical and theoretical applications to a large
 number of fields, mainly in science, technology and visual art.
 The aim of my project is to study the inverse Voronoi diagram problem and
 design, compare and analyze different strategies for its solving.
 The inverse Voronoi diagram problem consists on detecting whether a given
 plane partition is a Voronoi diagram and finding the seed points that would
 generate such a partition.
 For a partition which does not come from a Voronoi diagram, it would be
 interesting to find the best fitting Voronoi diagram.
 At this point, we need a way to measure how good a candidate solution is.
 We will be using the total symmetric difference between the two partitions.
 
\end_layout

\begin_layout Standard
Note that despite the search space is bounded, it being continuous grants
 an infinite number of solution candidates.
 Therefore, we will try to solve the problem using different metaheuristics,
 which makes it impossible to tell whether the obtained solution is optimum.
\end_layout

\begin_layout Standard
The basic steps of all the strategies are:
\end_layout

\begin_layout Itemize
For each input, calculate a set of seed points from which we will start.
\end_layout

\begin_layout Itemize
Move each point slightly following some criteria and check if we improved
 the current best solution.
\end_layout

\begin_layout Itemize
Repeat last step until we cannot keep improving or we are satisfied with
 the result.
\end_layout

\begin_layout Part*
RESUMEN
\end_layout

\begin_layout Standard
Los diagramas de Voronoi tienen aplicaciones tanto prácticas como teóricas
 en muchos ámbitos, la mayoría relacionados con la ciencia y tecnología,
 aunque también se aplica en otros como el arte visual.
 El objetivo de mi proyecto es estudiar el problema inverso del diagrama
 de Voronoi y diseñar, comparar y analizar diferentes estrategias para su
 resolución.
 Dicho problema consiste en detectar si una partición dada es o no un diagrama
 de Voronoi, y calcular las semillas que lo generan en caso afirmativo.
 Para particiones que no lo son, sería interesante encontrar el diagrama
 de Voronoi que mejor se aproxima.
 Para ello, necesitaremos alguna forma de evaluar como de buena es una solución.
 Usaremos la diferencia simétrica entre las dos particiones para tal fin.
\end_layout

\begin_layout Standard
Nótese que pese a que el espacio de búsqueda es acotado, al ser continuo
 hay infinitos candidatos que habría que probar, lo cual es inviable.
 Por tanto, trataremos de resolver el problema mediante diferentes metaheurístic
as, aunque en ningún caso podremos asegurar que la solución obtenida es
 óptima.
\end_layout

\begin_layout Standard
El esquema básico de todas las estrategias es el siguiente:
\end_layout

\begin_layout Itemize
Para cada datos de entrada, calcular un conjunto de puntos semilla a partir
 de los cuales comenzaremos la búsqueda.
\end_layout

\begin_layout Itemize
Desplazamos los puntos ligeramente según algún criterio y comprobamos si
 hemos conseguido mejorar nuestra solución, actualizando ésta en ese caso.
\end_layout

\begin_layout Itemize
Repetimos el paso anterior hasta que no podamos seguir mejorando o hasta
 que la solución obtenida se considere lo suficientemente buena.
\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Part*
INTRODUCTION
\end_layout

\begin_layout Standard
There are some concepts the reader should be familiar with in order to follow
 this document without problems.
 Those are:
\end_layout

\begin_layout Itemize
Partition of a set.
 Partition of the square unit.
\end_layout

\begin_layout Itemize
Voronoi diagrams.
\end_layout

\begin_layout Itemize
Symmetric difference.
\end_layout

\begin_layout Subsection*
Partition of a set.
 Partition of the square unit.
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
A partition of a set is a grouping of the set's elements into non-empty
 subsets, in such a way that every element is included in one and only one
 of the subsets.
\end_layout

\begin_layout Standard
For example, if we consider the set X = {1, 2, 3, 4, 5}, three different
 partitions could be:
\end_layout

\begin_layout Itemize
{1, 3}, {2, 4}, {5}
\end_layout

\begin_layout Itemize
{1, 2, 3}, {4, 5}
\end_layout

\begin_layout Itemize
{1}, {2}, {3}, {4}, {5}
\end_layout

\begin_layout Standard
In our case, we will be working with partitions of the square unit.
 That is, a set of polygons such that the union is the square unit and the
 intersection of two polygons is, at most, a segment.
 Note that there might be points contained in more than one polygon.
\end_layout

\begin_layout Subsection
Voronoi diagrams.
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
A Voronoi diagram is a partitioning of a plane into regions (called Voronoi
 cells) based on distance to points (called seeds or generators) in a specific
 subset of the plane.
 In this project we will only be using the simplest case of Voronoi diagrams:
 the seeds are given as a finite set of points in the Euclidian plane.
\end_layout

\begin_layout Standard
The lines that appear in a Voronoi diagram are the points of the plane that
 are equidistant to two or more of the nearest seeds.
\end_layout

\begin_layout Subsection*
Symmetric difference.
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
For measuring how good a given solution is, we will rely on the symmetric
 difference as an indicator.
 For two given polygons A and B, the symmetric difference can be calculated
 as follows:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
SD(A,B)=Area(A\bigcup B)-Area(A\bigcap B)
\]

\end_inset


\end_layout

\begin_layout Standard
Applying this concept to two partitions, we can define the symmetric difference
 of two partitions as the sum of all the symmetric differences for each
 pair of related polygons.
\end_layout

\begin_layout Standard
Since in this project we will only be interested in working with convex
 polygons, we can use that to our advantage and calculate the symmetric
 difference in a different way: we will substract from the square unit area,
 the areas of all the intersections of each pair of related polygons.
 This will be explained more in detail later, in the development chapter.
\end_layout

\begin_layout Standard
In order to avoid issues with scaling the programs window size, we will
 be treating this value as a ratio with the total area of the unit square,
 so a 0% value will mean the two partitions are exactly the same.
\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename ThesisImages/SymDiffOfTwoConvexPolygons.png
	scale 50

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename ThesisImages/SymDiffOfTwoPartitions.png
	scale 40

\end_inset


\end_layout

\begin_layout Subsection*
Inverse Voronoi problem.
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
As mentioned earlier, the inverse Voronoi diagram problem consists on detecting
 whether a given plane partition is a Voronoi diagram and finding the seed
 points that would generate such a partition.
 From the mathematical point of view, it is interesting that, for partitions
 that do come from a Voronoi diagram, the problem can be solved in O(n)
 time, n being the number of seeds of such a diagram.
\end_layout

\begin_layout Proof
We know the partition comes from a Voronoi diagram.
 TODO: Proof...
\end_layout

\begin_layout Proof
But what happens when the partition does not come from a Voronoi diagram?
 Even if it did, due to computers inaccuracy when representing floating-point
 numbers, the input data we have will not perfectly be the one that would
 be generated from a Voronoi diagram, but rather an approximation of it.
 Thus, we want to explore different methods of fitting an arbitrary partition,
 whether it comes from a Voronoi diagram.
\end_layout

\begin_layout Subsection*
Generalized inverse Voronoi problem.
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
Another problem related to the ones exposed, but beyond of the scope of
 this project, is the generalized inverse Voronoi problem.
 This problem consists of, given a plane partition, calculate a Voronoi
 diagram such that the given partition is contained on it.
 That is, add the necessary seeds so you get a partition which contains
 the one given.
\end_layout

\begin_layout Subsection*
Voronoi diagrams in real life.
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
TODO: Contar lo de los japoneses y los peces del libro de Manuel.
\end_layout

\begin_layout Standard
If one has the chance to go for a walk in Madrid, he/she might find itself
 in front of the 
\begin_inset Quotes eld
\end_inset

Teatros del Canal
\begin_inset Quotes erd
\end_inset

.
 If that person is familiar with Voronoi diagrams, something will catch
 his eye: some parts of the decoration of that building resemble those diagrams!
 Further in this project, we will adjust them and see how well they fit
 as a Voronoi diagram.
\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename ThesisImages/TeatrosDelCanalOriginal.png
	scale 35

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename ThesisImages/TeatrosDelCanalParticion.png
	scale 45

\end_inset


\end_layout

\begin_layout Part*
OBJECTIVES
\end_layout

\begin_layout Standard
The objectives of this project are:
\end_layout

\begin_layout Itemize
Fit a given partition of the square unit as much as we can through Voronoi
 diagrams.
 Therefore, the variable we want to minimize is the resulting symmetric
 difference between the input and the solution given.
 We want to implement different techniques and compare their results in
 a set of test cases.
\end_layout

\begin_layout Itemize
If the given partition is in fact a Voronoi diagram, we would like to arrive
 to that conclusion.
 Even though this looks trivial, it will be very difficult to get there
 for non trivial input, since the number of local minimums that have to
 be avoided to find the seeds increases in a higher magnitude compared to
 the number of polygons.
\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Part*
DEVELOPMENT
\end_layout

\begin_layout Subsection
Why Processing.
 Pros and cons of Java.
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
Despite Java not being the most efficent language out there for crunching
 raw numbers, I felt like I had to go with Processing for the development
 for a number of reasons:
\end_layout

\begin_layout Itemize
First of all, I had already used it in the past for a different project,
 and one of the biggest advantages of it is the ease to display information
 in the screen.
\end_layout

\begin_layout Itemize
The aim of this project is not to design an algorithm that can finish execution
 in the least amount of time, but rather, study and compare different techniques
 and their results.
\end_layout

\begin_layout Itemize
It is extremely portable across the different operative systems.
\end_layout

\begin_layout Itemize
Java's data structures come in handy for our problem.
 ArrayList's are used constantly in the code to contain information about
 the partitions and polygons.
\end_layout

\begin_layout Itemize
The number of regions we are going to be treating in our research will be
 200 maximum, a reasonable number for any modern programming language.
\end_layout

\begin_layout Subsection*
Calculating the Voronoi diagram from a set of seed points.
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
Even though I am using an already implemented library for calculating the
 Voronoi diagrams, here I will explain the most common methods for calculating
 a Voronoi diagram.
\end_layout

\begin_layout Subsection*
Line clipping.
 Polygon clipping.
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
There are two situations in the problem in which we have to calculate the
 intersection of two polygons: when clipping a polygon to the square unit
 and when clipping two polygons.
\end_layout

\begin_layout Standard
The first one is needed because, theoretically, there will always be some
 Voronoi region whose area will be infinite.
 In order to get rid of that issue, we must treat our Voronoi diagram in
 order to clip all regions into a bounded area, in our case, the square
 unit.
\end_layout

\begin_layout Standard
The second one is useful when we want to calculate the area of the intersection
 of two polygons for calculating the symmetric difference.
 This is doable since we will be working with convex polygons.
 An easy way to do it is calculate the actual intersection, and then, get
 the area of that polygon.
\end_layout

\begin_layout Standard
There is a simple, common operation in both tasks, to which these two problems
 can be reduced to: clip a polygon with a single line.
 If we have a solid function that can do this task, then we can rely on
 it to calculate any intersection of convex polygons (note that the square
 unit is a convex polygon too), repeating the process for all lines of one
 of the polygons against the other.
\end_layout

\begin_layout Standard
The algorithm works as follows:
\end_layout

\begin_layout Standard
Suppose we want to clip the polygon ABCDEFG with the blue line.
 Note that this polygon is not convex, but for explanation purposes, we
 will apply the algorithm to it.
 Also note that the line has a direction, given by the blue arrow.
\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename ThesisImages/LineClipping0.png
	scale 60

\end_inset


\end_layout

\begin_layout Standard
The first step of the clipping algorithm is to set a starting vertex.
 We will set A as our starting point.
 We must check in which side of the blue line it lies.
 We can do this using the cross product of two points of the line and our
 point.
 Since in the implementation we will be working with positively oriented
 polygons, we are interested only in points which lie on the left of the
 line.
 The point A is lying on the left, so we add it to the solution and continue.
\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename ThesisImages/LineClipping1.png
	scale 60

\end_inset


\end_layout

\begin_layout Standard
The next step is to select the next point and see whether it lies in the
 same side of the blue line.
 Since B also lies on the same side than A, we add it to the solution too
 and keep going.
\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename ThesisImages/LineClipping2.png
	scale 60

\end_inset


\end_layout

\begin_layout Standard
Same for C, still on the left.
\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename ThesisImages/LineClipping3.png
	scale 60

\end_inset


\end_layout

\begin_layout Standard
When we check D, we see that it is lying on the right side of the line.
 Then, we know that this point will be clipped by the line.
 Therefore, we need to find point P, which is the intersection of CD with
 the blue line.
 We will be adding this point to the solution.
\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename ThesisImages/LineClipping4.png
	scale 60

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename ThesisImages/LineClipping5.png
	scale 60

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename ThesisImages/LineClipping6.png
	scale 60

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename ThesisImages/LineClipping7.png
	scale 60

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename ThesisImages/LineClipping8.png
	scale 60

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename ThesisImages/LineClipping9.png
	scale 60

\end_inset


\end_layout

\begin_layout Subsection*
Input data.
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
The input data for the problem is a partition of the square unit.
 That is, a set of polygons whose union is the square unit and, for every
 two polygons, its intersection is at most a straight line.
 More precisely, each polygon is given as a set of ordered 2D points.
 At first, we know we will be working only with convex polygons (that is,
 all internal angles are less or equal than 180 degrees).
 The input data will be read from a *.txt file in which each line will contain
 a whole partition.
\end_layout

\begin_layout Standard
More in detail, this is the structure of the input data files:
\end_layout

\begin_layout Subsection*
Output data.
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
The program generates various files after being executed.
 The files will be located in the 
\begin_inset Quotes eld
\end_inset

voronoi
\begin_inset Quotes erd
\end_inset

 folder, and will be the following:
\end_layout

\begin_layout Itemize
output.csv: CSV file in which each line represents each iteration of the
 algorithm.
 Each line contains information of where each seed point was at that stage
 and the symmetric difference in that precise step.
\end_layout

\begin_layout Itemize
before.png: Image that displays the first approximation of the Voronoi diagram.
\end_layout

\begin_layout Itemize
after.png: Image that displays the final approximation of the Voronoi diagram.
\end_layout

\begin_layout Subsection*
Gradient method.
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
The gradient method is a simple heuristic used in optimization problems
 where the search space is not treatable.
 It consists on, at any given state, compare neighbour solutions against
 the current one.
 If they are better, take the best as the new current solution and repeat.
 If the minimum or maximum we are looking for is bounded, there will be
 a point at which we will not be able to continue improving.
 That will be our solution.
\end_layout

\begin_layout Standard
For example, consider you want to find the maximum value of a function.
 You start at a random point with a corresponding value.
 You will have to move to the left if the value at some distance to the
 left is higher, or to the right if the value at some distance to the right
 is higher.
 The problem with this is that we can easily get stuck in a local maximum.
\end_layout

\begin_layout Subsection*
Improved gradient method: implementing steps
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
One step closer to the simulated annealing, but still very similar to the
 gradient method.
 It consists on iterating different gradient methods, but varying the step
 size we are taking on each.
 This way, we will adjust our solution as much as possible, but this will
 not get us out of the local maximum.
\end_layout

\begin_layout Subsection*
Simulated annealing.
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
Simulated annealing copies a phenomenon in nature--the annealing of solids--to
 optimize a complex system.
 Annealing refers to heating a solid and then cooling it slowly.
 Atoms then assume a nearly globally minimum energy state.
 In 1953 Metropolis created an algorithm to simulate the annealing process.
 The algorithm simulates a small random displacement of an atom that results
 in a change in energy.
 If the change in energy is negative, the energy state of the new configuration
 is lower and the new configuration is accepted.
 TODO: explain more and better.
\end_layout

\begin_layout Subsubsection*
Getting rid of the 
\begin_inset Quotes eld
\end_inset

repetition
\begin_inset Quotes erd
\end_inset

 problem: randomizing point order in each state.
\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Part*
Bibliografía
\end_layout

\begin_layout Standard
https://processing.org – Open source programming language and IDE in which
 the whole project is coded 
\end_layout

\begin_layout Standard
http://leebyron.com/mesh/ - External processing library used for calculating
 the Voronoi diagrams
\end_layout

\begin_layout Standard
http://www.lyx.org/ - Document processor used for writing this thesis
\end_layout

\begin_layout Standard
https://github.com/Flood1993/TFG_voronoi - Git repository containing everything
 about this project
\end_layout

\begin_layout Standard
http://apmonitor.com/me575/index.php/Main/SimulatedAnnealing - Simulated annealing
\end_layout

\begin_layout Standard
http://www.exploringbinary.com/why-0-point-1-does-not-exist-in-floating-point/
 - Inaccuracy of computers when dealing with floating-point numbers
\end_layout

\end_body
\end_document
